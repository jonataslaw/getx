---
sidebar_position: 2
---

# À propos de GetX

- GetX est une solution extrêmement légère et puissante pour Flutter. Il combine la gestion de l'état de haute performance, l'injection intelligente de dépendances et la gestion des routes rapidement et pratiquement.

- GetX a 3 principes de base. Cela signifie qu'il s'agit de la priorité pour toutes les ressources de la bibliothèque : **PRODUCTIVITÉ, PERFORMANCE ET ORGANISATION.**

  - **PERFORMANCE :** GetX se concentre sur les performances et la consommation minimale des ressources. GetX n'utilise ni Streams ni ChangeNotifier.

  - **PRODUCTIVITÉ:** GetX utilise une syntaxe facile et agréable. Peu importe ce que vous voulez faire, il y a toujours un moyen plus simple avec GetX. Cela vous permettra de gagner des heures de développement et de fournir les performances maximales que votre application peut offrir.

    Généralement, le développeur devrait se soucier de supprimer les contrôleurs de la mémoire. Avec GetX, ce n'est pas nécessaire car les ressources sont retirées de la mémoire quand elles ne sont pas utilisées par défaut. Si vous voulez le conserver en mémoire, vous devez déclarer explicitement "permanent: true" dans votre dépendance. De cette façon, en plus de gagner du temps, vous risquez moins d'avoir des dépendances inutiles sur la mémoire. Le chargement des dépendances est également paresseux par défaut.

  - **ORGANISATION :** GetX permet le découplage total de la vue, de la logique de présentation, de la logique métier, de l'injection de dépendances et de la navigation. Vous n'avez pas besoin de contexte pour naviguer entre les routes, donc vous n'êtes pas dépendant de l'arborescence des widgets (visualisation) pour cela. Vous n'avez pas besoin de contexte pour accéder à vos contrôleurs/blocs à travers un héritedWidget, donc vous déconnectez complètement votre logique de présentation et votre logique métier de votre calque de visualisation. Vous n'avez pas besoin d'injecter vos classes Controllers/Models/Blocs dans votre arborescence de widgets via `MultiProvider`s. Pour cela, GetX utilise sa propre fonction d'injection de dépendance, découplant complètement le DI de sa vue.

    Avec GetX, vous savez où trouver chaque fonctionnalité de votre application, avec du code propre par défaut. En plus de faciliter la maintenance, cela rend le partage de modules quelque chose qui, jusque-là, dans Flutter était impensable, quelque chose de totalement possible.
    BLoC a été un point de départ pour organiser le code dans Flutter, il sépare la logique commerciale de la visualisation. GetX est une évolution naturelle de cela, non seulement en séparant la logique commerciale mais aussi la logique de présentation. Les injections supplémentaires de dépendances et de routes sont également découplées, et la couche de données est hors de tout. Vous savez où tout se trouve, et tout cela d'une manière plus facile que de construire un monde de bonjour.
    GetX est la façon la plus facile, pratique et évolutive de construire des applications hautes performances avec le Flutter SDK. Il a un grand écosystème autour de lui qui fonctionne parfaitement ensemble, il est facile pour les débutants, et il est précis pour les experts. Il est sécurisé, stable, à jour et offre une vaste gamme d'API intégrées qui ne sont pas présentes dans le SDK Flutter par défaut.

- GetX n'est pas gonflé. Il a une multitude de fonctionnalités qui vous permettent de commencer à programmer sans vous soucier de quoi que ce soit, mais chacune de ces fonctionnalités est dans des conteneurs séparés et ne démarre qu'après utilisation. Si vous n'utilisez que la gestion d'Etat, seule la gestion d'Etat sera compilée. Si vous n'utilisez que des routes, rien de la gestion de l'État ne sera compilé.

- GetX a un énorme écosystème, une grande communauté, un grand nombre de collaborateurs, et sera maintenu tant que le Flutter existe. GetX aussi est capable d'exécuter avec le même code sur Android, iOS, Web, Mac, Linux, Windows et sur votre serveur.
  **Il est possible de réutiliser complètement votre code fait sur le frontend de votre backend avec [Get Server](https://github.com/jonataslaw/get_server)**.

**De plus, l'ensemble du processus de développement peut être entièrement automatisé, tant sur le serveur que sur le front-end avec [Get CLI](https://github.com/jonataslaw/get_cli)**.

**En outre, pour augmenter votre productivité, nous avons l'extension
[pour VSCode](https://marketplace.visualstudio.com/items?itemName=get-snippets.get-snippets) et [l'extension pour Android Studio/Intellij](https://plugins.jetbrains.com/plugin/14975-getx-snippets)**

## Pourquoi Getx ?

1- Plusieurs fois après une mise à jour de Flut, beaucoup de vos paquets vont se briser. Parfois, des erreurs de compilation se produisent, des erreurs apparaissent souvent qu'il n'y a toujours aucune réponse, et le développeur a besoin de savoir d'où vient l'erreur, suivre l'erreur, puis essayer d'ouvrir un problème dans le référentiel correspondant, et voir son problème résolu. Permet de centraliser les principales ressources de développement (gestion de l'état, de la dépendance et de la route), vous permettant d'ajouter un seul paquet à votre pubspec, et de commencer à travailler. Après une mise à jour de Fluard, la seule chose à faire est de mettre à jour la dépendance Get et de se mettre au travail. Obtenir résout également les problèmes de compatibilité. Combien de fois une version d'un paquet n'est pas compatible avec la version d'un autre, parce que l'on utilise une dépendance dans une version, et l'autre dans une autre version ? Ce n'est pas non plus une préoccupation en utilisant Get, car tout est dans le même paquet et est entièrement compatible.

2- Flutter est facile, Flutter est incroyable, mais Flutter a encore quelques boilerplate qui peuvent être indésirables pour la plupart des développeurs, comme `Navigator. f(context).push (contexte, constructeur [...]`. Obtenir simplifie le développement. Au lieu d'écrire 8 lignes de code pour simplement appeler une route, tu peux juste le faire: `Get. o(Home())` et vous avez terminé, vous allez à la page suivante. Les URL web dynamiques sont une chose vraiment douloureuse à faire avec Flutter actuellement, et cela avec GetX est stupidement simple. La gestion des états dans Flutter, et la gestion des dépendances est également quelque chose qui génère beaucoup de discussions, car il y a des centaines de modèles dans le pub. Mais il n'y a rien d'aussi facile que d'ajouter un ". bs" à la fin de votre variable, et placez votre widget à l'intérieur d'un Obx, et c'est ça, toutes les mises à jour de cette variable seront automatiquement mises à jour à l'écran.

3- Faciliter sans se soucier des performances. Les performances de Flutter sont déjà incroyables, mais imaginez que vous utilisiez un gestionnaire d'état, et un localisateur pour distribuer vos classes de blocs/magasins/contrôleurs/etc. Vous devrez appeler manuellement l'exclusion de cette dépendance lorsque vous n'en avez pas besoin. Mais avez-vous déjà pensé à utiliser votre contrôleur, et quand il n'était plus utilisé par personne, il serait tout simplement supprimé de la mémoire ? C'est ce que fait GetX. Avec SmartManagement, tout ce qui n'est pas utilisé est supprimé de la mémoire, et vous ne devriez vous soucier que de la programmation. Vous serez assurés que vous consommez les ressources minimales nécessaires, sans même avoir créé une logique pour cela.

4- Le découplage effectif. Vous avez peut-être entendu le concept "séparer le point de vue de la logique commerciale". Ce n'est pas une particularité de BLoC, MVC, MVVM, et toute autre norme sur le marché a ce concept. Cependant, ce concept peut souvent être atténué dans Flutter en raison de l'utilisation du contexte.
Si vous avez besoin d'un contexte pour trouver un Widget Inhérité, vous en avez besoin dans la vue, ou passez le contexte par paramètre. Je trouve particulièrement cette solution très moche et pour travailler en équipe, nous dépendrons toujours de la logique commerciale de Views. Getx n'est pas orthodoxe avec l'approche standard, et bien qu'il ne bannisse pas complètement l'utilisation de StatefulWidgets, InitState, etc. elle a toujours une approche similaire qui peut être plus propre. Les contrôleurs ont des cycles de vie, et lorsque vous avez besoin de faire une demande APIREST par exemple, vous ne dépendez pas de quoi que ce soit dans la vue. Vous pouvez utiliser onInit pour lancer un appel http et quand les données arrivent, les variables seront remplies. Comme GetX est complètement réactif (vraiment, et fonctionne sous les streams), une fois que les éléments sont remplis, tous les widgets qui utilisent cette variable seront automatiquement mis à jour dans la vue. Cela permet aux personnes possédant l'expertise de l'interface de travailler uniquement avec des widgets, et ne pas avoir à envoyer quoi que ce soit à la logique commerciale autre que les événements utilisateur (comme cliquer sur un bouton), tandis que les personnes travaillant avec la logique commerciale seront libres de créer et de tester la logique commerciale séparément.

Cette bibliothèque sera toujours mise à jour et en implémentant de nouvelles fonctionnalités. N’hésitez pas à proposer des RP et à y contribuer.
